/*! For license information please see main.bundle.js.LICENSE.txt */
(self.webpackChunkthreejs_es6_webpack_boilerplate=self.webpackChunkthreejs_es6_webpack_boilerplate||[]).push([["main"],{"./src/js/app.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// Imports\nvar THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");\n\nvar SimplexNoise = __webpack_require__(/*! simplex-noise */ "./node_modules/simplex-noise/dist/cjs/commonjs-wrapper.js");\n\nvar MarchingCubes = __webpack_require__(/*! ./utils/marchingCubes.js */ "./src/js/utils/marchingCubes.js").MarchingCubes;\n\nvar OrbitControls = __webpack_require__(/*! ./utils/orbitControls.js */ "./src/js/utils/orbitControls.js"); // Global State\n\n\nvar globalState = {\n  running: true,\n  isolation: 100,\n  resolution: 16\n}; // Setup\n\nvar scene = new THREE.Scene();\nscene.background = new THREE.Color(0x050505);\nvar camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);\ncamera.position.set(100, 100, 500);\nvar renderer = new THREE.WebGLRenderer();\nrenderer.outputEncoding = THREE.sRGBEncoding;\nrenderer.setPixelRatio(window.devicePixelRatio);\nrenderer.setSize(window.innerWidth, window.innerHeight);\nvar controls = new OrbitControls(camera, renderer.domElement);\ncontrols.minDistance = 500;\ncontrols.maxDistance = 5000; // Scene Construction\n\nvar geometry = new THREE.SphereGeometry(10, 32, 32);\nvar material = new THREE.MeshStandardMaterial({\n  flatShading: true,\n  color: 0x55ffbb,\n  metalness: 1,\n  roughness: 0.4\n});\nvar cube = new THREE.Mesh(geometry, material);\ncube.position.y = 100;\nscene.add(cube);\nvar light = new THREE.DirectionalLight(0xffffff);\nlight.position.set(0.5, 0.5, 1);\nscene.add(light);\nvar pointLight = new THREE.PointLight(0xff3300);\npointLight.position.set(0, 0, 100);\nscene.add(pointLight);\nvar ambientLight = new THREE.AmbientLight(0x080808);\nscene.add(ambientLight); // Marching Cubes\n\nvar mesh = new MarchingCubes(globalState.resolution, material, true, true, 100000);\nmesh.position.set(0, 0, 0);\nmesh.scale.set(200, 200, 200);\nscene.add(mesh); // Render Loop\n\nfunction update(Δt) {\n  cube.rotation.y += 0.02;\n  controls.update();\n}\n\nfunction render(Δt, time) {\n  updateCubes(mesh, time / 10000, 10, true, false, false);\n  renderer.render(scene, camera);\n} // Frame Driver\n\n\nvar time = Date.now();\nvar start = Date.now();\n\nfunction animate() {\n  var now = Date.now();\n  var Δt = time - now;\n  time = now - start;\n  update(Δt, time);\n  render(Δt, time);\n  if (globalState.running) requestAnimationFrame(animate);\n} // Init\n\n\nmesh.init(Math.floor(globalState.resolution));\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\nanimate(); // -------\n\nvar simplex = new SimplexNoise(Math.random());\nconsole.log(SimplexNoise, simplex);\n\nfunction updateCubes(object, time, numblobs, floor, wallx, wallz) {\n  object.reset();\n  var subtract = 12;\n  var strength = 1.2 / ((Math.sqrt(numblobs) - 1) / 4 + 1);\n  var cx = 8 + 4 * Math.sin(time * 10);\n  var cy = 8 + 4 * Math.cos(time * 10);\n  var cz = 8 + 4 * -Math.sin(time * 10);\n  var value4d = simplex.noise4D(x, y, z, time);\n\n  for (var _x = 0; _x < 16; _x++) {\n    for (var _y = 0; _y < 16; _y++) {\n      for (var _z = 0; _z < 16; _z++) {\n        object.setCell(_x, _y, _z, value4d);\n      }\n    }\n  }\n}\n\n//# sourceURL=webpack://threejs-es6-webpack-boilerplate/./src/js/app.js?')},"./src/js/utils/marchingCubes.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");\n/**\n * Port of http://webglsamples.org/blob/blob.html\n */\n\n\nvar MarchingCubes = /*#__PURE__*/function (_THREE$Mesh) {\n  _inherits(MarchingCubes, _THREE$Mesh);\n\n  var _super = _createSuper(MarchingCubes);\n\n  function MarchingCubes(resolution, material) {\n    var _this;\n\n    var enableUvs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var enableColors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var maxPolyCount = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 10000;\n\n    _classCallCheck(this, MarchingCubes);\n\n    var geometry = new THREE.BufferGeometry();\n    _this = _super.call(this, geometry, material);\n\n    var scope = _assertThisInitialized(_this); // temp buffers used in polygonize\n\n\n    var vlist = new Float32Array(12 * 3);\n    var nlist = new Float32Array(12 * 3);\n    var clist = new Float32Array(12 * 3);\n    _this.enableUvs = enableUvs;\n    _this.enableColors = enableColors; // functions have to be object properties\n    // prototype functions kill performance\n    // (tested and it was 4x slower !!!)\n\n    _this.init = function (resolution) {\n      // parameters\n      this.resolution = resolution;\n      this.isolation = 80.0; // size of field, 32 is pushing it in Javascript :)\n\n      this.size = resolution;\n      this.size2 = this.size * this.size;\n      this.size3 = this.size2 * this.size;\n      this.halfsize = this.size / 2.0; // deltas\n\n      this.delta = 2.0 / this.size;\n      this.yd = this.size;\n      this.zd = this.size2;\n      this.field = new Float32Array(this.size3);\n      this.normal_cache = new Float32Array(this.size3 * 3);\n      this.palette = new Float32Array(this.size3 * 3); //\n\n      this.count = 0;\n      var maxVertexCount = maxPolyCount * 3;\n      this.positionArray = new Float32Array(maxVertexCount * 3);\n      var positionAttribute = new THREE.BufferAttribute(this.positionArray, 3);\n      positionAttribute.setUsage(THREE.DynamicDrawUsage);\n      geometry.setAttribute(\'position\', positionAttribute);\n      this.normalArray = new Float32Array(maxVertexCount * 3);\n      var normalAttribute = new THREE.BufferAttribute(this.normalArray, 3);\n      normalAttribute.setUsage(THREE.DynamicDrawUsage);\n      geometry.setAttribute(\'normal\', normalAttribute);\n\n      if (this.enableUvs) {\n        this.uvArray = new Float32Array(maxVertexCount * 2);\n        var uvAttribute = new THREE.BufferAttribute(this.uvArray, 2);\n        uvAttribute.setUsage(THREE.DynamicDrawUsage);\n        geometry.setAttribute(\'uv\', uvAttribute);\n      }\n\n      if (this.enableColors) {\n        this.colorArray = new Float32Array(maxVertexCount * 3);\n        var colorAttribute = new THREE.BufferAttribute(this.colorArray, 3);\n        colorAttribute.setUsage(THREE.DynamicDrawUsage);\n        geometry.setAttribute(\'color\', colorAttribute);\n      }\n    }; ///////////////////////\n    // Polygonization\n    ///////////////////////\n\n\n    function lerp(a, b, t) {\n      return a + (b - a) * t;\n    }\n\n    function VIntX(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {\n      var mu = (isol - valp1) / (valp2 - valp1),\n          nc = scope.normal_cache;\n      vlist[offset + 0] = x + mu * scope.delta;\n      vlist[offset + 1] = y;\n      vlist[offset + 2] = z;\n      nlist[offset + 0] = lerp(nc[q + 0], nc[q + 3], mu);\n      nlist[offset + 1] = lerp(nc[q + 1], nc[q + 4], mu);\n      nlist[offset + 2] = lerp(nc[q + 2], nc[q + 5], mu);\n      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);\n      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);\n      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);\n    }\n\n    function VIntY(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {\n      var mu = (isol - valp1) / (valp2 - valp1),\n          nc = scope.normal_cache;\n      vlist[offset + 0] = x;\n      vlist[offset + 1] = y + mu * scope.delta;\n      vlist[offset + 2] = z;\n      var q2 = q + scope.yd * 3;\n      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);\n      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);\n      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);\n      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);\n      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);\n      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);\n    }\n\n    function VIntZ(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {\n      var mu = (isol - valp1) / (valp2 - valp1),\n          nc = scope.normal_cache;\n      vlist[offset + 0] = x;\n      vlist[offset + 1] = y;\n      vlist[offset + 2] = z + mu * scope.delta;\n      var q2 = q + scope.zd * 3;\n      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);\n      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);\n      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);\n      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);\n      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);\n      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);\n    }\n\n    function compNorm(q) {\n      var q3 = q * 3;\n\n      if (scope.normal_cache[q3] === 0.0) {\n        scope.normal_cache[q3 + 0] = scope.field[q - 1] - scope.field[q + 1];\n        scope.normal_cache[q3 + 1] = scope.field[q - scope.yd] - scope.field[q + scope.yd];\n        scope.normal_cache[q3 + 2] = scope.field[q - scope.zd] - scope.field[q + scope.zd];\n      }\n    } // Returns total number of triangles. Fills triangles.\n    // (this is where most of time is spent - it\'s inner work of O(n3) loop )\n\n\n    function polygonize(fx, fy, fz, q, isol) {\n      var q1 = q + 1,\n          qy = q + scope.yd,\n          qz = q + scope.zd,\n          q1y = q1 + scope.yd,\n          q1z = q1 + scope.zd,\n          qyz = q + scope.yd + scope.zd,\n          q1yz = q1 + scope.yd + scope.zd;\n      var cubeindex = 0;\n      var field0 = scope.field[q],\n          field1 = scope.field[q1],\n          field2 = scope.field[qy],\n          field3 = scope.field[q1y],\n          field4 = scope.field[qz],\n          field5 = scope.field[q1z],\n          field6 = scope.field[qyz],\n          field7 = scope.field[q1yz];\n      if (field0 < isol) cubeindex |= 1;\n      if (field1 < isol) cubeindex |= 2;\n      if (field2 < isol) cubeindex |= 8;\n      if (field3 < isol) cubeindex |= 4;\n      if (field4 < isol) cubeindex |= 16;\n      if (field5 < isol) cubeindex |= 32;\n      if (field6 < isol) cubeindex |= 128;\n      if (field7 < isol) cubeindex |= 64; // if cube is entirely in/out of the surface - bail, nothing to draw\n\n      var bits = edgeTable[cubeindex];\n      if (bits === 0) return 0;\n      var d = scope.delta,\n          fx2 = fx + d,\n          fy2 = fy + d,\n          fz2 = fz + d; // top of the cube\n\n      if (bits & 1) {\n        compNorm(q);\n        compNorm(q1);\n        VIntX(q * 3, 0, isol, fx, fy, fz, field0, field1, q, q1);\n      }\n\n      if (bits & 2) {\n        compNorm(q1);\n        compNorm(q1y);\n        VIntY(q1 * 3, 3, isol, fx2, fy, fz, field1, field3, q1, q1y);\n      }\n\n      if (bits & 4) {\n        compNorm(qy);\n        compNorm(q1y);\n        VIntX(qy * 3, 6, isol, fx, fy2, fz, field2, field3, qy, q1y);\n      }\n\n      if (bits & 8) {\n        compNorm(q);\n        compNorm(qy);\n        VIntY(q * 3, 9, isol, fx, fy, fz, field0, field2, q, qy);\n      } // bottom of the cube\n\n\n      if (bits & 16) {\n        compNorm(qz);\n        compNorm(q1z);\n        VIntX(qz * 3, 12, isol, fx, fy, fz2, field4, field5, qz, q1z);\n      }\n\n      if (bits & 32) {\n        compNorm(q1z);\n        compNorm(q1yz);\n        VIntY(q1z * 3, 15, isol, fx2, fy, fz2, field5, field7, q1z, q1yz);\n      }\n\n      if (bits & 64) {\n        compNorm(qyz);\n        compNorm(q1yz);\n        VIntX(qyz * 3, 18, isol, fx, fy2, fz2, field6, field7, qyz, q1yz);\n      }\n\n      if (bits & 128) {\n        compNorm(qz);\n        compNorm(qyz);\n        VIntY(qz * 3, 21, isol, fx, fy, fz2, field4, field6, qz, qyz);\n      } // vertical lines of the cube\n\n\n      if (bits & 256) {\n        compNorm(q);\n        compNorm(qz);\n        VIntZ(q * 3, 24, isol, fx, fy, fz, field0, field4, q, qz);\n      }\n\n      if (bits & 512) {\n        compNorm(q1);\n        compNorm(q1z);\n        VIntZ(q1 * 3, 27, isol, fx2, fy, fz, field1, field5, q1, q1z);\n      }\n\n      if (bits & 1024) {\n        compNorm(q1y);\n        compNorm(q1yz);\n        VIntZ(q1y * 3, 30, isol, fx2, fy2, fz, field3, field7, q1y, q1yz);\n      }\n\n      if (bits & 2048) {\n        compNorm(qy);\n        compNorm(qyz);\n        VIntZ(qy * 3, 33, isol, fx, fy2, fz, field2, field6, qy, qyz);\n      }\n\n      cubeindex <<= 4; // re-purpose cubeindex into an offset into triTable\n\n      var o1,\n          o2,\n          o3,\n          numtris = 0,\n          i = 0; // here is where triangles are created\n\n      while (triTable[cubeindex + i] != -1) {\n        o1 = cubeindex + i;\n        o2 = o1 + 1;\n        o3 = o1 + 2;\n        posnormtriv(vlist, nlist, clist, 3 * triTable[o1], 3 * triTable[o2], 3 * triTable[o3]);\n        i += 3;\n        numtris++;\n      }\n\n      return numtris;\n    }\n\n    function posnormtriv(pos, norm, colors, o1, o2, o3) {\n      var c = scope.count * 3; // positions\n\n      scope.positionArray[c + 0] = pos[o1];\n      scope.positionArray[c + 1] = pos[o1 + 1];\n      scope.positionArray[c + 2] = pos[o1 + 2];\n      scope.positionArray[c + 3] = pos[o2];\n      scope.positionArray[c + 4] = pos[o2 + 1];\n      scope.positionArray[c + 5] = pos[o2 + 2];\n      scope.positionArray[c + 6] = pos[o3];\n      scope.positionArray[c + 7] = pos[o3 + 1];\n      scope.positionArray[c + 8] = pos[o3 + 2]; // normals\n\n      if (scope.material.flatShading === true) {\n        var nx = (norm[o1 + 0] + norm[o2 + 0] + norm[o3 + 0]) / 3;\n        var ny = (norm[o1 + 1] + norm[o2 + 1] + norm[o3 + 1]) / 3;\n        var nz = (norm[o1 + 2] + norm[o2 + 2] + norm[o3 + 2]) / 3;\n        scope.normalArray[c + 0] = nx;\n        scope.normalArray[c + 1] = ny;\n        scope.normalArray[c + 2] = nz;\n        scope.normalArray[c + 3] = nx;\n        scope.normalArray[c + 4] = ny;\n        scope.normalArray[c + 5] = nz;\n        scope.normalArray[c + 6] = nx;\n        scope.normalArray[c + 7] = ny;\n        scope.normalArray[c + 8] = nz;\n      } else {\n        scope.normalArray[c + 0] = norm[o1 + 0];\n        scope.normalArray[c + 1] = norm[o1 + 1];\n        scope.normalArray[c + 2] = norm[o1 + 2];\n        scope.normalArray[c + 3] = norm[o2 + 0];\n        scope.normalArray[c + 4] = norm[o2 + 1];\n        scope.normalArray[c + 5] = norm[o2 + 2];\n        scope.normalArray[c + 6] = norm[o3 + 0];\n        scope.normalArray[c + 7] = norm[o3 + 1];\n        scope.normalArray[c + 8] = norm[o3 + 2];\n      } // uvs\n\n\n      if (scope.enableUvs) {\n        var d = scope.count * 2;\n        scope.uvArray[d + 0] = pos[o1 + 0];\n        scope.uvArray[d + 1] = pos[o1 + 2];\n        scope.uvArray[d + 2] = pos[o2 + 0];\n        scope.uvArray[d + 3] = pos[o2 + 2];\n        scope.uvArray[d + 4] = pos[o3 + 0];\n        scope.uvArray[d + 5] = pos[o3 + 2];\n      } // colors\n\n\n      if (scope.enableColors) {\n        scope.colorArray[c + 0] = colors[o1 + 0];\n        scope.colorArray[c + 1] = colors[o1 + 1];\n        scope.colorArray[c + 2] = colors[o1 + 2];\n        scope.colorArray[c + 3] = colors[o2 + 0];\n        scope.colorArray[c + 4] = colors[o2 + 1];\n        scope.colorArray[c + 5] = colors[o2 + 2];\n        scope.colorArray[c + 6] = colors[o3 + 0];\n        scope.colorArray[c + 7] = colors[o3 + 1];\n        scope.colorArray[c + 8] = colors[o3 + 2];\n      }\n\n      scope.count += 3;\n    } /////////////////////////////////////\n    // Metaballs\n    /////////////////////////////////////\n    // Adds a reciprocal ball (nice and blobby) that, to be fast, fades to zero after\n    // a fixed distance, determined by strength and subtract.\n\n\n    _this.addBall = function (ballx, bally, ballz, strength, subtract, colors) {\n      var sign = Math.sign(strength);\n      strength = Math.abs(strength);\n      var userDefineColor = !(colors === undefined || colors === null);\n      var ballColor = new THREE.Color(ballx, bally, ballz);\n\n      if (userDefineColor) {\n        try {\n          ballColor = colors instanceof THREE.Color ? colors : Array.isArray(colors) ? new THREE.Color(Math.min(Math.abs(colors[0]), 1), Math.min(Math.abs(colors[1]), 1), Math.min(Math.abs(colors[2]), 1)) : new THREE.Color(colors);\n        } catch (err) {\n          ballColor = new THREE.Color(ballx, bally, ballz);\n        }\n      } // Let\'s solve the equation to find the radius:\n      // 1.0 / (0.000001 + radius^2) * strength - subtract = 0\n      // strength / (radius^2) = subtract\n      // strength = subtract * radius^2\n      // radius^2 = strength / subtract\n      // radius = sqrt(strength / subtract)\n\n\n      var radius = this.size * Math.sqrt(strength / subtract),\n          zs = ballz * this.size,\n          ys = bally * this.size,\n          xs = ballx * this.size;\n      var min_z = Math.floor(zs - radius);\n      if (min_z < 1) min_z = 1;\n      var max_z = Math.floor(zs + radius);\n      if (max_z > this.size - 1) max_z = this.size - 1;\n      var min_y = Math.floor(ys - radius);\n      if (min_y < 1) min_y = 1;\n      var max_y = Math.floor(ys + radius);\n      if (max_y > this.size - 1) max_y = this.size - 1;\n      var min_x = Math.floor(xs - radius);\n      if (min_x < 1) min_x = 1;\n      var max_x = Math.floor(xs + radius);\n      if (max_x > this.size - 1) max_x = this.size - 1; // Don\'t polygonize in the outer layer because normals aren\'t\n      // well-defined there.\n\n      var x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val;\n\n      for (z = min_z; z < max_z; z++) {\n        z_offset = this.size2 * z;\n        fz = z / this.size - ballz;\n        fz2 = fz * fz;\n\n        for (y = min_y; y < max_y; y++) {\n          y_offset = z_offset + this.size * y;\n          fy = y / this.size - bally;\n          fy2 = fy * fy;\n\n          for (x = min_x; x < max_x; x++) {\n            fx = x / this.size - ballx;\n            val = strength / (0.000001 + fx * fx + fy2 + fz2) - subtract;\n\n            if (val > 0.0) {\n              this.field[y_offset + x] += val * sign; // optimization\n              // http://www.geisswerks.com/ryan/BLOBS/blobs.html\n\n              var ratio = Math.sqrt((x - xs) * (x - xs) + (y - ys) * (y - ys) + (z - zs) * (z - zs)) / radius;\n              var contrib = 1 - ratio * ratio * ratio * (ratio * (ratio * 6 - 15) + 10);\n              this.palette[(y_offset + x) * 3 + 0] += ballColor.r * contrib;\n              this.palette[(y_offset + x) * 3 + 1] += ballColor.g * contrib;\n              this.palette[(y_offset + x) * 3 + 2] += ballColor.b * contrib;\n            }\n          }\n        }\n      }\n    };\n\n    _this.addPlaneX = function (strength, subtract) {\n      var size = this.size,\n          yd = this.yd,\n          zd = this.zd,\n          field = this.field;\n      var x,\n          y,\n          z,\n          xx,\n          val,\n          xdiv,\n          cxy,\n          dist = size * Math.sqrt(strength / subtract);\n      if (dist > size) dist = size;\n\n      for (x = 0; x < dist; x++) {\n        xdiv = x / size;\n        xx = xdiv * xdiv;\n        val = strength / (0.0001 + xx) - subtract;\n\n        if (val > 0.0) {\n          for (y = 0; y < size; y++) {\n            cxy = x + y * yd;\n\n            for (z = 0; z < size; z++) {\n              field[zd * z + cxy] += val;\n            }\n          }\n        }\n      }\n    };\n\n    _this.addPlaneY = function (strength, subtract) {\n      var size = this.size,\n          yd = this.yd,\n          zd = this.zd,\n          field = this.field;\n      var x,\n          y,\n          z,\n          yy,\n          val,\n          ydiv,\n          cy,\n          cxy,\n          dist = size * Math.sqrt(strength / subtract);\n      if (dist > size) dist = size;\n\n      for (y = 0; y < dist; y++) {\n        ydiv = y / size;\n        yy = ydiv * ydiv;\n        val = strength / (0.0001 + yy) - subtract;\n\n        if (val > 0.0) {\n          cy = y * yd;\n\n          for (x = 0; x < size; x++) {\n            cxy = cy + x;\n\n            for (z = 0; z < size; z++) {\n              field[zd * z + cxy] += val;\n            }\n          }\n        }\n      }\n    };\n\n    _this.addPlaneZ = function (strength, subtract) {\n      var size = this.size,\n          yd = this.yd,\n          zd = this.zd,\n          field = this.field;\n      var x,\n          y,\n          z,\n          zz,\n          val,\n          zdiv,\n          cz,\n          cyz,\n          dist = size * Math.sqrt(strength / subtract);\n      if (dist > size) dist = size;\n\n      for (z = 0; z < dist; z++) {\n        zdiv = z / size;\n        zz = zdiv * zdiv;\n        val = strength / (0.0001 + zz) - subtract;\n\n        if (val > 0.0) {\n          cz = zd * z;\n\n          for (y = 0; y < size; y++) {\n            cyz = cz + y * yd;\n\n            for (x = 0; x < size; x++) {\n              field[cyz + x] += val;\n            }\n          }\n        }\n      }\n    }; /////////////////////////////////////\n    // Updates\n    /////////////////////////////////////\n\n\n    _this.setCell = function (x, y, z, value) {\n      var index = this.size2 * z + this.size * y + x;\n      this.field[index] = value;\n    };\n\n    _this.getCell = function (x, y, z) {\n      var index = this.size2 * z + this.size * y + x;\n      return this.field[index];\n    };\n\n    _this.blur = function () {\n      var intensity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var field = this.field;\n      var fieldCopy = field.slice();\n      var size = this.size;\n      var size2 = this.size2;\n\n      for (var x = 0; x < size; x++) {\n        for (var y = 0; y < size; y++) {\n          for (var z = 0; z < size; z++) {\n            var index = size2 * z + size * y + x;\n            var val = fieldCopy[index];\n            var count = 1;\n\n            for (var x2 = -1; x2 <= 1; x2 += 2) {\n              var x3 = x2 + x;\n              if (x3 < 0 || x3 >= size) continue;\n\n              for (var y2 = -1; y2 <= 1; y2 += 2) {\n                var y3 = y2 + y;\n                if (y3 < 0 || y3 >= size) continue;\n\n                for (var z2 = -1; z2 <= 1; z2 += 2) {\n                  var z3 = z2 + z;\n                  if (z3 < 0 || z3 >= size) continue;\n                  var index2 = size2 * z3 + size * y3 + x3;\n                  var val2 = fieldCopy[index2];\n                  count++;\n                  val += intensity * (val2 - val) / count;\n                }\n              }\n            }\n\n            field[index] = val;\n          }\n        }\n      }\n    };\n\n    _this.reset = function () {\n      for (var i = 0; i < this.size3; i++) {\n        this.normal_cache[i * 3] = 0.0;\n        this.field[i] = 0.0;\n        this.palette[i * 3] = this.palette[i * 3 + 1] = this.palette[i * 3 + 2] = 0.0;\n      }\n    };\n\n    _this.onBeforeRender = function () {\n      this.count = 0; // Triangulate. Yeah, this is slow.\n\n      var smin2 = this.size - 2;\n\n      for (var z = 1; z < smin2; z++) {\n        var z_offset = this.size2 * z;\n        var fz = (z - this.halfsize) / this.halfsize; //+ 1\n\n        for (var y = 1; y < smin2; y++) {\n          var y_offset = z_offset + this.size * y;\n          var fy = (y - this.halfsize) / this.halfsize; //+ 1\n\n          for (var x = 1; x < smin2; x++) {\n            var fx = (x - this.halfsize) / this.halfsize; //+ 1\n\n            var q = y_offset + x;\n            polygonize(fx, fy, fz, q, this.isolation);\n          }\n        }\n      } // reset unneeded data\n\n\n      for (var i = this.count * 3; i < this.positionArray.length; i++) {\n        this.positionArray[i] = 0.0;\n      } // update geometry data\n\n\n      geometry.getAttribute(\'position\').needsUpdate = true;\n      geometry.getAttribute(\'normal\').needsUpdate = true;\n      if (this.enableUvs) geometry.getAttribute(\'uv\').needsUpdate = true;\n      if (this.enableColors) geometry.getAttribute(\'color\').needsUpdate = true; // safety check\n\n      if (this.count / 3 > maxPolyCount) console.warn(\'THREE.MarchingCubes: Geometry buffers too small for rendering. Please create an instance with a higher poly count.\');\n    };\n\n    _this.init(resolution);\n\n    return _this;\n  }\n\n  return MarchingCubes;\n}(THREE.Mesh);\n\nMarchingCubes.prototype.isMarchingCubes = true; /////////////////////////////////////\n// Marching cubes lookup tables\n/////////////////////////////////////\n// These tables are straight from Paul Bourke\'s page:\n// http://paulbourke.net/geometry/polygonise/\n// who in turn got them from Cory Gene Bloyd.\n\nvar edgeTable = new Int32Array([0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460, 0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0]);\nvar triTable = new Int32Array([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1, 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1, 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1, 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1, 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1, 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1, 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1, 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1, 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1, 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1, 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1, 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1, 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1, 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1, 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1, 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1, 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1, 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1, 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1, 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1, 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1, 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1, 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1, 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1, 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1, 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1, 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1, 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1, 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]);\nmodule.exports.edgeTable = edgeTable;\nmodule.exports.triTable = triTable;\nmodule.exports.MarchingCubes = MarchingCubes;\n\n//# sourceURL=webpack://threejs-es6-webpack-boilerplate/./src/js/utils/marchingCubes.js?')},"./src/js/utils/orbitControls.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n\n\nvar MOUSE = THREE.MOUSE;\nif (!MOUSE) MOUSE = {\n  LEFT: 0,\n  MIDDLE: 1,\n  RIGHT: 2\n};\n\nfunction OrbitConstraint(object) {\n  this.object = object; // \"target\" sets the location of focus, where the object orbits around\n  // and where it pans with respect to.\n\n  this.target = new THREE.Vector3(); // Limits to how far you can dolly in and out ( PerspectiveCamera only )\n\n  this.minDistance = 0;\n  this.maxDistance = Infinity; // Limits to how far you can zoom in and out ( OrthographicCamera only )\n\n  this.minZoom = 0;\n  this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.\n  // Range is 0 to Math.PI radians.\n\n  this.minPolarAngle = 0; // radians\n\n  this.maxPolarAngle = Math.PI; // radians\n  // How far you can orbit horizontally, upper and lower limits.\n  // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\n  this.minAzimuthAngle = -Infinity; // radians\n\n  this.maxAzimuthAngle = Infinity; // radians\n  // Set to true to enable damping (inertia)\n  // If damping is enabled, you must call controls.update() in your animation loop\n\n  this.enableDamping = false;\n  this.dampingFactor = 0.25; ////////////\n  // internals\n\n  var scope = this;\n  var EPS = 0.000001; // Current position in spherical coordinate system.\n\n  var theta;\n  var phi; // Pending changes\n\n  var phiDelta = 0;\n  var thetaDelta = 0;\n  var scale = 1;\n  var panOffset = new THREE.Vector3();\n  var zoomChanged = false; // API\n\n  this.getPolarAngle = function () {\n    return phi;\n  };\n\n  this.getAzimuthalAngle = function () {\n    return theta;\n  };\n\n  this.rotateLeft = function (angle) {\n    thetaDelta -= angle;\n  };\n\n  this.rotateUp = function (angle) {\n    phiDelta -= angle;\n  }; // pass in distance in world space to move left\n\n\n  this.panLeft = function () {\n    var v = new THREE.Vector3();\n    return function panLeft(distance) {\n      var te = this.object.matrix.elements; // get X column of matrix\n\n      v.set(te[0], te[1], te[2]);\n      v.multiplyScalar(-distance);\n      panOffset.add(v);\n    };\n  }(); // pass in distance in world space to move up\n\n\n  this.panUp = function () {\n    var v = new THREE.Vector3();\n    return function panUp(distance) {\n      var te = this.object.matrix.elements; // get Y column of matrix\n\n      v.set(te[4], te[5], te[6]);\n      v.multiplyScalar(distance);\n      panOffset.add(v);\n    };\n  }(); // pass in x,y of change desired in pixel space,\n  // right and down are positive\n\n\n  this.pan = function (deltaX, deltaY, screenWidth, screenHeight) {\n    if (scope.object instanceof THREE.PerspectiveCamera) {\n      // perspective\n      var position = scope.object.position;\n      var offset = position.clone().sub(scope.target);\n      var targetDistance = offset.length(); // half of the fov is center to top of screen\n\n      targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0); // we actually don't use screenWidth, since perspective camera is fixed to screen height\n\n      scope.panLeft(2 * deltaX * targetDistance / screenHeight);\n      scope.panUp(2 * deltaY * targetDistance / screenHeight);\n    } else if (scope.object instanceof THREE.OrthographicCamera) {\n      // orthographic\n      scope.panLeft(deltaX * (scope.object.right - scope.object.left) / screenWidth);\n      scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / screenHeight);\n    } else {\n      // camera neither orthographic or perspective\n      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n    }\n  };\n\n  this.dollyIn = function (dollyScale) {\n    if (scope.object instanceof THREE.PerspectiveCamera) {\n      scale /= dollyScale;\n    } else if (scope.object instanceof THREE.OrthographicCamera) {\n      scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale));\n      scope.object.updateProjectionMatrix();\n      zoomChanged = true;\n    } else {\n      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n    }\n  };\n\n  this.dollyOut = function (dollyScale) {\n    if (scope.object instanceof THREE.PerspectiveCamera) {\n      scale *= dollyScale;\n    } else if (scope.object instanceof THREE.OrthographicCamera) {\n      scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale));\n      scope.object.updateProjectionMatrix();\n      zoomChanged = true;\n    } else {\n      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n    }\n  };\n\n  this.update = function () {\n    var offset = new THREE.Vector3(); // so camera.up is the orbit axis\n\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n    return function () {\n      var position = this.object.position;\n      offset.copy(position).sub(this.target); // rotate offset to \"y-axis-is-up\" space\n\n      offset.applyQuaternion(quat); // angle from z-axis around y-axis\n\n      theta = Math.atan2(offset.x, offset.z); // angle from y-axis\n\n      phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n      theta += thetaDelta;\n      phi += phiDelta; // restrict theta to be between desired limits\n\n      theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta)); // restrict phi to be between desired limits\n\n      phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi)); // restrict phi to be betwee EPS and PI-EPS\n\n      phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n      var radius = offset.length() * scale; // restrict radius to be between desired limits\n\n      radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius)); // move target to panned location\n\n      this.target.add(panOffset);\n      offset.x = radius * Math.sin(phi) * Math.sin(theta);\n      offset.y = radius * Math.cos(phi);\n      offset.z = radius * Math.sin(phi) * Math.cos(theta); // rotate offset back to \"camera-up-vector-is-up\" space\n\n      offset.applyQuaternion(quatInverse);\n      position.copy(this.target).add(offset);\n      this.object.lookAt(this.target);\n\n      if (this.enableDamping === true) {\n        thetaDelta *= 1 - this.dampingFactor;\n        phiDelta *= 1 - this.dampingFactor;\n      } else {\n        thetaDelta = 0;\n        phiDelta = 0;\n      }\n\n      scale = 1;\n      panOffset.set(0, 0, 0); // update condition is:\n      // min(camera displacement, camera rotation in radians)^2 > EPS\n      // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n      if (zoomChanged || lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n        lastPosition.copy(this.object.position);\n        lastQuaternion.copy(this.object.quaternion);\n        zoomChanged = false;\n        return true;\n      }\n\n      return false;\n    };\n  }();\n} // This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\n\nfunction OrbitControls(object, domElement) {\n  var constraint = new OrbitConstraint(object);\n  this.domElement = domElement !== undefined ? domElement : document; // API\n\n  Object.defineProperty(this, 'constraint', {\n    get: function get() {\n      return constraint;\n    }\n  });\n\n  this.getPolarAngle = function () {\n    return constraint.getPolarAngle();\n  };\n\n  this.getAzimuthalAngle = function () {\n    return constraint.getAzimuthalAngle();\n  }; // Set to false to disable this control\n\n\n  this.enabled = true; // center is old, deprecated; use \"target\" instead\n\n  this.center = this.target; // This option actually enables dollying in and out; left as \"zoom\" for\n  // backwards compatibility.\n  // Set to false to disable zooming\n\n  this.enableZoom = true;\n  this.zoomSpeed = 1.0; // Set to false to disable rotating\n\n  this.enableRotate = true;\n  this.rotateSpeed = 1.0; // Set to false to disable panning\n\n  this.enablePan = true;\n  this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n  // Set to true to automatically rotate around the target\n  // If auto-rotate is enabled, you must call controls.update() in your animation loop\n\n  this.autoRotate = false;\n  this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n  // Set to false to disable use of the keys\n\n  this.enableKeys = true; // The four arrow keys\n\n  this.keys = {\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    BOTTOM: 40\n  }; // Mouse buttons\n\n  this.mouseButtons = {\n    ORBIT: THREE.MOUSE.LEFT,\n    ZOOM: THREE.MOUSE.MIDDLE,\n    PAN: THREE.MOUSE.RIGHT\n  }; ////////////\n  // internals\n\n  var scope = this;\n  var rotateStart = new THREE.Vector2();\n  var rotateEnd = new THREE.Vector2();\n  var rotateDelta = new THREE.Vector2();\n  var panStart = new THREE.Vector2();\n  var panEnd = new THREE.Vector2();\n  var panDelta = new THREE.Vector2();\n  var dollyStart = new THREE.Vector2();\n  var dollyEnd = new THREE.Vector2();\n  var dollyDelta = new THREE.Vector2();\n  var STATE = {\n    NONE: -1,\n    ROTATE: 0,\n    DOLLY: 1,\n    PAN: 2,\n    TOUCH_ROTATE: 3,\n    TOUCH_DOLLY: 4,\n    TOUCH_PAN: 5\n  };\n  var state = STATE.NONE; // for reset\n\n  this.target0 = this.target.clone();\n  this.position0 = this.object.position.clone();\n  this.zoom0 = this.object.zoom; // events\n\n  var changeEvent = {\n    type: 'change'\n  };\n  var startEvent = {\n    type: 'start'\n  };\n  var endEvent = {\n    type: 'end'\n  }; // pass in x,y of change desired in pixel space,\n  // right and down are positive\n\n  function pan(deltaX, deltaY) {\n    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n    constraint.pan(deltaX, deltaY, element.clientWidth, element.clientHeight);\n  }\n\n  this.update = function () {\n    if (this.autoRotate && state === STATE.NONE) {\n      constraint.rotateLeft(getAutoRotationAngle());\n    }\n\n    if (constraint.update() === true) {\n      this.dispatchEvent(changeEvent);\n    }\n  };\n\n  this.reset = function () {\n    state = STATE.NONE;\n    this.target.copy(this.target0);\n    this.object.position.copy(this.position0);\n    this.object.zoom = this.zoom0;\n    this.object.updateProjectionMatrix();\n    this.dispatchEvent(changeEvent);\n    this.update();\n  };\n\n  function getAutoRotationAngle() {\n    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n  }\n\n  function getZoomScale() {\n    return Math.pow(0.95, scope.zoomSpeed);\n  }\n\n  function onMouseDown(event) {\n    if (scope.enabled === false) return;\n    event.preventDefault();\n\n    if (event.button === scope.mouseButtons.ORBIT) {\n      if (scope.enableRotate === false) return;\n      state = STATE.ROTATE;\n      rotateStart.set(event.clientX, event.clientY);\n    } else if (event.button === scope.mouseButtons.ZOOM) {\n      if (scope.enableZoom === false) return;\n      state = STATE.DOLLY;\n      dollyStart.set(event.clientX, event.clientY);\n    } else if (event.button === scope.mouseButtons.PAN) {\n      if (scope.enablePan === false) return;\n      state = STATE.PAN;\n      panStart.set(event.clientX, event.clientY);\n    }\n\n    if (state !== STATE.NONE) {\n      document.addEventListener('mousemove', onMouseMove, false);\n      document.addEventListener('mouseup', onMouseUp, false);\n      scope.dispatchEvent(startEvent);\n    }\n  }\n\n  function onMouseMove(event) {\n    if (scope.enabled === false) return;\n    event.preventDefault();\n    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n    if (state === STATE.ROTATE) {\n      if (scope.enableRotate === false) return;\n      rotateEnd.set(event.clientX, event.clientY);\n      rotateDelta.subVectors(rotateEnd, rotateStart); // rotating across whole screen goes 360 degrees around\n\n      constraint.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed); // rotating up and down along whole screen attempts to go 360, but limited to 180\n\n      constraint.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n      rotateStart.copy(rotateEnd);\n    } else if (state === STATE.DOLLY) {\n      if (scope.enableZoom === false) return;\n      dollyEnd.set(event.clientX, event.clientY);\n      dollyDelta.subVectors(dollyEnd, dollyStart);\n\n      if (dollyDelta.y > 0) {\n        constraint.dollyIn(getZoomScale());\n      } else if (dollyDelta.y < 0) {\n        constraint.dollyOut(getZoomScale());\n      }\n\n      dollyStart.copy(dollyEnd);\n    } else if (state === STATE.PAN) {\n      if (scope.enablePan === false) return;\n      panEnd.set(event.clientX, event.clientY);\n      panDelta.subVectors(panEnd, panStart);\n      pan(panDelta.x, panDelta.y);\n      panStart.copy(panEnd);\n    }\n\n    if (state !== STATE.NONE) scope.update();\n  }\n\n  function onMouseUp()\n  /* event */\n  {\n    if (scope.enabled === false) return;\n    document.removeEventListener('mousemove', onMouseMove, false);\n    document.removeEventListener('mouseup', onMouseUp, false);\n    scope.dispatchEvent(endEvent);\n    state = STATE.NONE;\n  }\n\n  function onMouseWheel(event) {\n    if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;\n    event.preventDefault();\n    event.stopPropagation();\n    var delta = 0;\n\n    if (event.wheelDelta !== undefined) {\n      // WebKit / Opera / Explorer 9\n      delta = event.wheelDelta;\n    } else if (event.detail !== undefined) {\n      // Firefox\n      delta = -event.detail;\n    }\n\n    if (delta > 0) {\n      constraint.dollyOut(getZoomScale());\n    } else if (delta < 0) {\n      constraint.dollyIn(getZoomScale());\n    }\n\n    scope.update();\n    scope.dispatchEvent(startEvent);\n    scope.dispatchEvent(endEvent);\n  }\n\n  function onKeyDown(event) {\n    if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;\n\n    switch (event.keyCode) {\n      case scope.keys.UP:\n        pan(0, scope.keyPanSpeed);\n        scope.update();\n        break;\n\n      case scope.keys.BOTTOM:\n        pan(0, -scope.keyPanSpeed);\n        scope.update();\n        break;\n\n      case scope.keys.LEFT:\n        pan(scope.keyPanSpeed, 0);\n        scope.update();\n        break;\n\n      case scope.keys.RIGHT:\n        pan(-scope.keyPanSpeed, 0);\n        scope.update();\n        break;\n    }\n  }\n\n  function touchstart(event) {\n    if (scope.enabled === false) return;\n\n    switch (event.touches.length) {\n      case 1:\n        // one-fingered touch: rotate\n        if (scope.enableRotate === false) return;\n        state = STATE.TOUCH_ROTATE;\n        rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n        break;\n\n      case 2:\n        // two-fingered touch: dolly\n        if (scope.enableZoom === false) return;\n        state = STATE.TOUCH_DOLLY;\n        var dx = event.touches[0].pageX - event.touches[1].pageX;\n        var dy = event.touches[0].pageY - event.touches[1].pageY;\n        var distance = Math.sqrt(dx * dx + dy * dy);\n        dollyStart.set(0, distance);\n        break;\n\n      case 3:\n        // three-fingered touch: pan\n        if (scope.enablePan === false) return;\n        state = STATE.TOUCH_PAN;\n        panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n        break;\n\n      default:\n        state = STATE.NONE;\n    }\n\n    if (state !== STATE.NONE) scope.dispatchEvent(startEvent);\n  }\n\n  function touchmove(event) {\n    if (scope.enabled === false) return;\n    event.preventDefault();\n    event.stopPropagation();\n    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n    switch (event.touches.length) {\n      case 1:\n        // one-fingered touch: rotate\n        if (scope.enableRotate === false) return;\n        if (state !== STATE.TOUCH_ROTATE) return;\n        rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n        rotateDelta.subVectors(rotateEnd, rotateStart); // rotating across whole screen goes 360 degrees around\n\n        constraint.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed); // rotating up and down along whole screen attempts to go 360, but limited to 180\n\n        constraint.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n        rotateStart.copy(rotateEnd);\n        scope.update();\n        break;\n\n      case 2:\n        // two-fingered touch: dolly\n        if (scope.enableZoom === false) return;\n        if (state !== STATE.TOUCH_DOLLY) return;\n        var dx = event.touches[0].pageX - event.touches[1].pageX;\n        var dy = event.touches[0].pageY - event.touches[1].pageY;\n        var distance = Math.sqrt(dx * dx + dy * dy);\n        dollyEnd.set(0, distance);\n        dollyDelta.subVectors(dollyEnd, dollyStart);\n\n        if (dollyDelta.y > 0) {\n          constraint.dollyOut(getZoomScale());\n        } else if (dollyDelta.y < 0) {\n          constraint.dollyIn(getZoomScale());\n        }\n\n        dollyStart.copy(dollyEnd);\n        scope.update();\n        break;\n\n      case 3:\n        // three-fingered touch: pan\n        if (scope.enablePan === false) return;\n        if (state !== STATE.TOUCH_PAN) return;\n        panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n        panDelta.subVectors(panEnd, panStart);\n        pan(panDelta.x, panDelta.y);\n        panStart.copy(panEnd);\n        scope.update();\n        break;\n\n      default:\n        state = STATE.NONE;\n    }\n  }\n\n  function touchend()\n  /* event */\n  {\n    if (scope.enabled === false) return;\n    scope.dispatchEvent(endEvent);\n    state = STATE.NONE;\n  }\n\n  function contextmenu(event) {\n    event.preventDefault();\n  }\n\n  this.dispose = function () {\n    this.domElement.removeEventListener('contextmenu', contextmenu, false);\n    this.domElement.removeEventListener('mousedown', onMouseDown, false);\n    this.domElement.removeEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.removeEventListener('MozMousePixelScroll', onMouseWheel, false); // firefox\n\n    this.domElement.removeEventListener('touchstart', touchstart, false);\n    this.domElement.removeEventListener('touchend', touchend, false);\n    this.domElement.removeEventListener('touchmove', touchmove, false);\n    document.removeEventListener('mousemove', onMouseMove, false);\n    document.removeEventListener('mouseup', onMouseUp, false);\n    window.removeEventListener('keydown', onKeyDown, false);\n  };\n\n  this.domElement.addEventListener('contextmenu', contextmenu, false);\n  this.domElement.addEventListener('mousedown', onMouseDown, false);\n  this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n  this.domElement.addEventListener('MozMousePixelScroll', onMouseWheel, false); // firefox\n\n  this.domElement.addEventListener('touchstart', touchstart, false);\n  this.domElement.addEventListener('touchend', touchend, false);\n  this.domElement.addEventListener('touchmove', touchmove, false);\n  window.addEventListener('keydown', onKeyDown, false); // force an update at start\n\n  this.update();\n}\n\nOrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nOrbitControls.prototype.constructor = OrbitControls;\nObject.defineProperties(OrbitControls.prototype, {\n  object: {\n    get: function get() {\n      return this.constraint.object;\n    }\n  },\n  target: {\n    get: function get() {\n      return this.constraint.target;\n    },\n    set: function set(value) {\n      console.warn('THREE.OrbitControls: target is now immutable. Use target.set() instead.');\n      this.constraint.target.copy(value);\n    }\n  },\n  minDistance: {\n    get: function get() {\n      return this.constraint.minDistance;\n    },\n    set: function set(value) {\n      this.constraint.minDistance = value;\n    }\n  },\n  maxDistance: {\n    get: function get() {\n      return this.constraint.maxDistance;\n    },\n    set: function set(value) {\n      this.constraint.maxDistance = value;\n    }\n  },\n  minZoom: {\n    get: function get() {\n      return this.constraint.minZoom;\n    },\n    set: function set(value) {\n      this.constraint.minZoom = value;\n    }\n  },\n  maxZoom: {\n    get: function get() {\n      return this.constraint.maxZoom;\n    },\n    set: function set(value) {\n      this.constraint.maxZoom = value;\n    }\n  },\n  minPolarAngle: {\n    get: function get() {\n      return this.constraint.minPolarAngle;\n    },\n    set: function set(value) {\n      this.constraint.minPolarAngle = value;\n    }\n  },\n  maxPolarAngle: {\n    get: function get() {\n      return this.constraint.maxPolarAngle;\n    },\n    set: function set(value) {\n      this.constraint.maxPolarAngle = value;\n    }\n  },\n  minAzimuthAngle: {\n    get: function get() {\n      return this.constraint.minAzimuthAngle;\n    },\n    set: function set(value) {\n      this.constraint.minAzimuthAngle = value;\n    }\n  },\n  maxAzimuthAngle: {\n    get: function get() {\n      return this.constraint.maxAzimuthAngle;\n    },\n    set: function set(value) {\n      this.constraint.maxAzimuthAngle = value;\n    }\n  },\n  enableDamping: {\n    get: function get() {\n      return this.constraint.enableDamping;\n    },\n    set: function set(value) {\n      this.constraint.enableDamping = value;\n    }\n  },\n  dampingFactor: {\n    get: function get() {\n      return this.constraint.dampingFactor;\n    },\n    set: function set(value) {\n      this.constraint.dampingFactor = value;\n    }\n  },\n  // backward compatibility\n  noZoom: {\n    get: function get() {\n      console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n      return !this.enableZoom;\n    },\n    set: function set(value) {\n      console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n      this.enableZoom = !value;\n    }\n  },\n  noRotate: {\n    get: function get() {\n      console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n      return !this.enableRotate;\n    },\n    set: function set(value) {\n      console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n      this.enableRotate = !value;\n    }\n  },\n  noPan: {\n    get: function get() {\n      console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n      return !this.enablePan;\n    },\n    set: function set(value) {\n      console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n      this.enablePan = !value;\n    }\n  },\n  noKeys: {\n    get: function get() {\n      console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n      return !this.enableKeys;\n    },\n    set: function set(value) {\n      console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n      this.enableKeys = !value;\n    }\n  },\n  staticMoving: {\n    get: function get() {\n      console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n      return !this.constraint.enableDamping;\n    },\n    set: function set(value) {\n      console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n      this.constraint.enableDamping = !value;\n    }\n  },\n  dynamicDampingFactor: {\n    get: function get() {\n      console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n      return this.constraint.dampingFactor;\n    },\n    set: function set(value) {\n      console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n      this.constraint.dampingFactor = value;\n    }\n  }\n});\nmodule.exports = OrbitControls;\n\n//# sourceURL=webpack://threejs-es6-webpack-boilerplate/./src/js/utils/orbitControls.js?")}},n=>{"use strict";n.O(0,["vendors"],(()=>{return e="./src/js/app.js",n(n.s=e);var e}));n.O()}]);